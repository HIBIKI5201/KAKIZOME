#pragma kernel Phase1
#pragma kernel Phase2
#pragma kernel Phase3
#pragma kernel PhaseFinal
#pragma kernel ColorUpdate

#define TAU 6.28318530718
#define AIR_RESISTANCE 0.95

RWStructuredBuffer<float3> PositionBuffer;
RWStructuredBuffer<float3> VelocityBuffer;
RWStructuredBuffer<float3> TargetBuffer;
RWStructuredBuffer<float3> ColorBuffer;

float Time;
float DeltaTime;
uint ParticleCount;

// フェーズ0情報
float Radius;

// フェーズ1情報
RWStructuredBuffer<uint> Phase1Indices;
uint Phase1Count;
float3 CenterPosition;

// フェーズ2情報
RWStructuredBuffer<uint> Phase2Indices;
uint Phase2Count;

// フェーズ3情報
RWStructuredBuffer<uint> Phase3Indices;
uint Phase3Count;

// 最終フェーズ情報
RWStructuredBuffer<uint> PhaseFinalIndices;
uint PhaseFinalCount;

float StopDistance;
float Speed;

float Hash01(uint n)
{
    return frac(sin(n * 12.9898) * 43758.5453);
}

uint HashUint(uint x)
{
    x = (x ^ 61) ^ (x >> 16);
    x *= 9;
    x = x ^ (x >> 4);
    x *= 0x27d4eb2d;
    x = x ^ (x >> 15);
    return x;
}

[numthreads(64, 1, 1)]
void Phase1(uint id : SV_DispatchThreadID)
{
    if (id >= Phase1Count)
    {
        return;
    }
    
    // インデックスバッファからパーティクルのインデックスを取得。
    uint i = Phase1Indices[id];
    
    float3 pos = PositionBuffer[i];
    
    float3 dir = normalize(CenterPosition - pos);
         
    // 中心から遠ざかる。
    pos -= dir * Speed * DeltaTime;
    PositionBuffer[i] = pos;
}

[numthreads(64, 1, 1)]
void Phase2(uint id : SV_DispatchThreadID)
{
    if (id >= Phase2Count)
    {
        return;
    }

    uint i = Phase2Indices[id];

    float3 pos = PositionBuffer[i];
    float3 vel = VelocityBuffer[i];

    // ----- パラメータ -----
    float MinRadius = 10;
    float MaxRadius = 20;
    float RadiusForce = 6;
    float YSpring = 10;
    float OrbitalSpeed = 6;

    // パーティクル固有値。
    float seed = Hash01(i);
    float baseRadius = lerp(MinRadius, MaxRadius, seed);
    float initialAngle = seed * TAU; // 0～2πの間。
    
    // 厚みノイズ。
    float jitter = (MaxRadius - MinRadius) * 0.05 * (seed - 0.5);
    float targetRadius = baseRadius + jitter;

    // 円環の平面ベクトル
    float3 toPos = pos - CenterPosition;
    toPos.y = 0.0;
    float r = length(toPos);
    r = max(r, 0.0001);
    float3 normalized = toPos / r;
    float3 tangent = float3(-normalized.z, 0, normalized.x);

    // 公転運動。
    float angularSpeed = OrbitalSpeed / max(targetRadius, MinRadius);
    float3 targetTangentVel = tangent * (angularSpeed * targetRadius);
    float3 currentTangentVel = dot(vel, tangent) * tangent;
    
    vel += (targetTangentVel - currentTangentVel) * 4 * DeltaTime;

    float rError = targetRadius - r;
    vel += normalized * rError * RadiusForce * DeltaTime;

    // Y軸のバネ挙動。
    float yErr = CenterPosition.y - pos.y;
    vel.y += yErr * YSpring * DeltaTime;

    vel *= AIR_RESISTANCE; // 空気抵抗。

    pos += vel * DeltaTime;

    PositionBuffer[i] = pos;
    VelocityBuffer[i] = vel;
}

[numthreads(64, 1, 1)]
void Phase3(uint id : SV_DispatchThreadID)
{
    if (id >= Phase3Count)
    {
        return;
    }
    
    uint i = Phase3Indices[id];
    
    float3 pos = PositionBuffer[i];
    float3 vel = VelocityBuffer[i];

    // パラメータ。
    uint SphereCount = 5;
    float OrbitalRadius = 15.0;
    float SphereRadius = 3.0;
    float OrbitalSpeed = 1.0;
    float3 CenterOffset = float3(0, 5, 0);

    // 所属する球のインデックス。
    uint sphereIndex = HashUint(i) % SphereCount;

    // 各球の位相（均等配置）
    float spherePhase = (sphereIndex / (float) SphereCount) * TAU;

    // 時間による公転。
    float angle = Time * OrbitalSpeed + spherePhase;

    float3 offsetedCenter = CenterPosition + CenterOffset;
    
    float3 orbitCenter;
    orbitCenter.x = offsetedCenter.x + cos(angle) * OrbitalRadius;
    orbitCenter.z = offsetedCenter.z + sin(angle) * OrbitalRadius;
    orbitCenter.y = offsetedCenter.y;
    
    // 球表面上の分布（球ごとに安定）
    uint localSeed = i / SphereCount;

    float seed1 = Hash01(localSeed * 17 + sphereIndex * 131);
    float seed2 = Hash01(localSeed * 59 + sphereIndex * 241);

    float theta = seed1 * TAU;
    float phi = acos(1.0 - 2.0 * seed2);

    float3 sphereDir;
    sphereDir.x = sin(phi) * cos(theta);
    sphereDir.y = cos(phi);
    sphereDir.z = sin(phi) * sin(theta);
    
    float3 targetPos = orbitCenter + sphereDir * SphereRadius;
    
    float3 diff = targetPos - pos;

    vel += diff * Speed * DeltaTime;
    vel *= AIR_RESISTANCE;

    pos += vel * DeltaTime;

    PositionBuffer[i] = pos;
    VelocityBuffer[i] = vel;
}


[numthreads(64, 1, 1)]
void PhaseFinal(uint id : SV_DispatchThreadID)
{
    if (id >= PhaseFinalCount)
    {
        return;
    }
    
    // インデックスバッファからパーティクルのインデックスを取得。
    uint i = PhaseFinalIndices[id];
    
    float3 target = TargetBuffer[i];
    float3 pos = PositionBuffer[i];
    
    float3 diff = target - pos;
    float dist = length(diff);
    float3 dir = diff / dist;
    
    if (dist <= StopDistance)
    {
        // ストップしたらターゲット位置にスナップ。
        PositionBuffer[i] = target;
        return;
    }
    
    // ターゲットに向かって移動。
    pos += dir * Speed * DeltaTime;
    PositionBuffer[i] = pos;
}

// HSVをRGBに変換する。
float3 HSVtoRGB(float h, float s, float v)
{
    float c = v * s;
    float h_prime = h * 6.0;
    float x = c * (1 - abs(fmod(h_prime, 2.0) - 1));
    float3 rgb = float3(0, 0, 0);
    
    if (0 <= h_prime && h_prime < 1)
        rgb = float3(c, x, 0);
    else if (1 <= h_prime && h_prime < 2)
        rgb = float3(x, c, 0);
    else if (2 <= h_prime && h_prime < 3)
        rgb = float3(0, c, x);
    else if (3 <= h_prime && h_prime < 4)
        rgb = float3(0, x, c);
    else if (4 <= h_prime && h_prime < 5)
        rgb = float3(x, 0, c);
    else if (5 <= h_prime && h_prime < 6)
        rgb = float3(c, 0, x);

    float m_val = v - c;
    return rgb + float3(m_val, m_val, m_val);
}

[numthreads(256, 1, 1)]
void ColorUpdate(uint3 id : SV_DispatchThreadID)
{
    float n = 5; // 内側の範囲。
    float m = 8; // グラデーション範囲。
    float centerGradationTime = 0.2;
    
    uint index = id.x;
    if (index >= ParticleCount)
    {
        return;
    }
    
    float3 pos = PositionBuffer[index];
    float3 diff = pos - CenterPosition;

    float dist = length(diff.xz); // XZ平面の距離。
    float3 color = float3(1, 1, 1); // デフォルトは白色。

    if (dist <= n)
    {
        // 内側は時間に応じたグラデーション。
        float hue = fmod(Time * centerGradationTime, 1);
        color = HSVtoRGB(hue, 1, 1);
    }
    else
    {
        float angle = atan2(diff.z, diff.x) / (2.0 * 3.14159265); // -0.5から0.5。
        if (angle < 0)
        {
            angle += 1;
        }
        
        if (dist <= m)
        {
            // グラデーション（中央から色相環）
            float t = (dist - n) / (m - n); // 0は内側、1は外側。
            float hue = lerp(1 / 6, angle, t); // 中央から色相環へのLerp。
            
            color = HSVtoRGB(hue, 1, 1);
        }
        else
        {
            // 外側は角度に応じた色相環。    
            color = HSVtoRGB(angle, 1, 1);
        }
    }

    ColorBuffer[index] = color;
}