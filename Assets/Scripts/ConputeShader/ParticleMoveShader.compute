#pragma kernel Phase1
#pragma kernel Phase2
#pragma kernel Phase3
#pragma kernel PhaseFinal
#pragma kernel ColorUpdate

#define TAU 6.28318530718
#define AIR_RESISTANCE 0.95

RWStructuredBuffer<float3> PositionBuffer;
RWStructuredBuffer<float3> VelocityBuffer;
RWStructuredBuffer<float3> TargetBuffer;
RWStructuredBuffer<float3> ColorBuffer;

uint ParticleCount;
float3 CenterPosition;

float Time;
float DeltaTime;

// フェーズ1情報
RWStructuredBuffer<uint> Phase1Indices;
uint Phase1Count;
float Phase1Accel;

// フェーズ2情報
RWStructuredBuffer<uint> Phase2Indices;
uint Phase2Count;
float TorusSpeed;
float TorusMinRadius;
float TorusMaxRadius;
float TorusYSpring;
float TorusTangentGain;
float TorusRadiusGain;

// フェーズ3情報
RWStructuredBuffer<uint> Phase3Indices;
uint Phase3Count;
uint OrbitalSphereCount;
float OrbitalSphereRadius;
float3 OrbitalCenterOffset;
float OrbitalSpeed;
float OrbitalMaxRadius;
float OrbitalMinRadius;
float OrbitalPosGain;
float OrbitalVelGain;

// 最終フェーズ情報
RWStructuredBuffer<uint> PhaseFinalIndices;
uint PhaseFinalCount;
float StopDistance;
float PhaseFinalFollowGain;

float Hash01(uint n)
{
    return frac(sin(n * 12.9898) * 43758.5453);
}

uint HashUint(uint x)
{
    x = (x ^ 61) ^ (x >> 16);
    x *= 9;
    x = x ^ (x >> 4);
    x *= 0x27d4eb2d;
    x = x ^ (x >> 15);
    return x;
}

void Integrate(uint i, inout float3 pos, inout float3 vel, float3 acc)
{
    vel += acc * DeltaTime;
    vel *= AIR_RESISTANCE;
    pos += vel * DeltaTime;

    PositionBuffer[i] = pos;
    VelocityBuffer[i] = vel;
}

// PD制御関数
float3 PDControl(float3 currentPos, float3 currentVel, float3 targetPos, float3 targetVel, float posGain, float velGain)
{
    float3 posError = targetPos - currentPos;
    float3 velError = targetVel - currentVel;
    return posError * posGain + velError * velGain;
}


// 中心から離れるように加速するフェーズ。
[numthreads(64, 1, 1)]
void Phase1(uint id : SV_DispatchThreadID)
{
    if (id >= Phase1Count)
    {
        return;
    }
    
    // インデックスバッファからパーティクルのインデックスを取得。
    uint i = Phase1Indices[id];
    
    float3 pos = PositionBuffer[i];
    float3 vel = VelocityBuffer[i];
    
    // 中心から遠ざかる。
    float3 acc = normalize(pos - CenterPosition) * Phase1Accel;
    
    Integrate(i, pos, vel, acc);
}

// 円環を回るフェーズ。
[numthreads(64, 1, 1)]
void Phase2(uint id : SV_DispatchThreadID)
{
    if (id >= Phase2Count)
    {
        return;
    }

    uint i = Phase2Indices[id];

    float3 pos = PositionBuffer[i];
    float3 vel = VelocityBuffer[i];

    // パーティクル固有値。
    float seed = Hash01(i);
    float baseRadius = lerp(TorusMinRadius, TorusMaxRadius, seed);
    float initialAngle = seed * TAU;
    
    // 厚みノイズ。
    float jitter = (TorusMaxRadius - TorusMinRadius) * 0.05 * (seed - 0.5);
    float targetRadius = baseRadius + jitter;

    // 円環の平面ベクトル。
    float3 toPos = pos - CenterPosition;
    toPos.y = 0.0;
    float r = length(toPos);
    r = max(r, 0.0001);
    float3 normalized = toPos / r;
    float3 tangent = float3(-normalized.z, 0, normalized.x);

    // 公転運動の加速度。
    float angularSpeed = TorusSpeed / max(targetRadius, TorusMinRadius);
    float3 targetTangentVel = tangent * (angularSpeed * targetRadius);
    float3 currentTangentVel = dot(vel, tangent) * tangent;
    float3 tangentAcc = (targetTangentVel - currentTangentVel) * TorusTangentGain;

    // 半径方向の加速度。
    float rError = targetRadius - r;
    float3 radialAcc = normalized * rError * TorusRadiusGain;

    // Y軸のバネ挙動の加速度。
    float yErr = CenterPosition.y - pos.y;
    float3 yAcc = float3(0, yErr * TorusYSpring, 0);

    float3 acc = tangentAcc + radialAcc + yAcc;
    
    Integrate(i, pos, vel, acc);
}

// 公転する衛星のフェーズ。
[numthreads(64, 1, 1)]
void Phase3(uint id : SV_DispatchThreadID)
{
    if (id >= Phase3Count)
    {
        return;
    }
    
    uint i = Phase3Indices[id];
    
    float3 pos = PositionBuffer[i];
    float3 vel = VelocityBuffer[i];

    float t = (cos(Time) + 1) / 2.0;
    float orbitalRadius = lerp(OrbitalMinRadius, OrbitalMaxRadius, t);
    
    // 所属する球のインデックス。
    uint sphereIndex = HashUint(i) % OrbitalSphereCount;

    // 各球の位相（均等配置）
    float spherePhase = (sphereIndex / (float) OrbitalSphereCount) * TAU;

    // 時間による公転。
    float angle = Time * OrbitalSpeed + spherePhase;

    float3 offsetedCenter = CenterPosition + OrbitalCenterOffset;
    
    float s, c;
    sincos(angle, s, c);

    float3 orbitCenter;
    orbitCenter.x = offsetedCenter.x + c * orbitalRadius;
    orbitCenter.z = offsetedCenter.z + s * orbitalRadius;
    orbitCenter.y = offsetedCenter.y;
    
    // 球表面上の分布（球ごとに安定）
    uint localSeed = i / OrbitalSphereCount;

    float seed1 = Hash01(localSeed * 17 + sphereIndex * 131);
    float seed2 = Hash01(localSeed * 59 + sphereIndex * 241);

    float theta = seed1 * TAU;
    float phi = acos(1.0 - 2.0 * seed2);

    float3 sphereDir;
    sphereDir.x = sin(phi) * cos(theta);
    sphereDir.y = cos(phi);
    sphereDir.z = sin(phi) * sin(theta);
    
    float3 targetPos = orbitCenter + sphereDir * OrbitalSphereRadius;
    
    float3 acc = PDControl(pos, vel, targetPos, float3(0, 0, 0), OrbitalPosGain, OrbitalVelGain);

    Integrate(i, pos, vel, acc);
}


// あけおめ文字フェーズ。
[numthreads(64, 1, 1)]
void PhaseFinal(uint id : SV_DispatchThreadID)
{
    if (id >= PhaseFinalCount)
    {
        return;
    }
    
    // インデックスバッファからパーティクルのインデックスを取得。
    uint i = PhaseFinalIndices[id];
    
    float3 target = TargetBuffer[i];
    float3 pos = PositionBuffer[i];
    float3 vel = VelocityBuffer[i];
    
    float3 diff = target - pos;
    float dist = length(diff);
    
    if (dist <= StopDistance)
    {
        // ストップしたらターゲット位置にスナップ。
        PositionBuffer[i] = target;
        VelocityBuffer[i] = float3(0, 0, 0);
        return;
    }
    
    // ターゲットに向かって移動。
    float3 acc = normalize(diff) * PhaseFinalFollowGain;

    Integrate(i, pos, vel, acc);
}

// HSVをRGBに変換する。
float3 HSVtoRGB(float h, float s, float v)
{
    // HSV2RGB汎用関数を使用。
    float4 k = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(h + k.xyz) * 6.0 - k.www);
    return v * lerp(k.xxx, saturate(p - k.xxx), s);
}

[numthreads(256, 1, 1)]
void ColorUpdate(uint3 id : SV_DispatchThreadID)
{
    float n = 5; // 内側の範囲。
    float m = 8; // グラデーション範囲。
    float centerGradationTime = 0.2;
    
    uint index = id.x;
    if (index >= ParticleCount)
    {
        return;
    }
    
    float3 pos = PositionBuffer[index];
    float3 diff = pos - CenterPosition;

    float dist = length(diff.xz); // XZ平面の距離。
    float3 color = float3(1, 1, 1); // デフォルトは白色。

    if (dist <= n)
    {
        // 内側は時間に応じたグラデーション。
        float hue = fmod(Time * centerGradationTime, 1);
        color = HSVtoRGB(hue, 1, 1);
    }
    else
    {
        float angle = atan2(diff.z, diff.x) / (2.0 * 3.14159265); // -0.5から0.5。
        if (angle < 0)
        {
            angle += 1;
        }
        
        if (dist <= m)
        {
            // グラデーション（中央から色相環）
            float t = (dist - n) / (m - n); // 0は内側、1は外側。
            float hue = lerp(1 / 6, angle, t); // 中央から色相環へのLerp。
            
            color = HSVtoRGB(hue, 1, 1);
        }
        else
        {
            // 外側は角度に応じた色相環。    
            color = HSVtoRGB(angle, 1, 1);
        }
    }

    ColorBuffer[index] = color;
}