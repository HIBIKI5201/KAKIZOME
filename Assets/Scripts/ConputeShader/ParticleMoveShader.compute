#pragma kernel Phase1
#pragma kernel Phase2
#pragma kernel Phase3
#pragma kernel PhaseFinal
#pragma kernel ColorUpdate

#define TAU 6.28318530718
#define AIR_RESISTANCE 0.95

RWStructuredBuffer<float3> PositionBuffer;
RWStructuredBuffer<float3> VelocityBuffer;
RWStructuredBuffer<float3> TargetBuffer;
RWStructuredBuffer<float3> ColorBuffer;

uint ParticleCount;
float Speed;
float3 CenterPosition;

float Time;
float DeltaTime;

// フェーズ1情報
RWStructuredBuffer<uint> Phase1Indices;
uint Phase1Count;

// フェーズ2情報
RWStructuredBuffer<uint> Phase2Indices;
uint Phase2Count;
float TorusSpeed;
float TorusMinRadius;
float TorusMaxRadius;
float TorusYSpring;

// フェーズ3情報
RWStructuredBuffer<uint> Phase3Indices;
uint Phase3Count;
uint OrbitalSphereCount;
float OrbitalSphereRadius;
float3 OrbitalCenterOffset;
float OrbitalSpeed;
float OrbitalMaxRadius;
float OrbitalMinRadius;

// 最終フェーズ情報
RWStructuredBuffer<uint> PhaseFinalIndices;
uint PhaseFinalCount;
float StopDistance;

float Hash01(uint n)
{
    return frac(sin(n * 12.9898) * 43758.5453);
}

uint HashUint(uint x)
{
    x = (x ^ 61) ^ (x >> 16);
    x *= 9;
    x = x ^ (x >> 4);
    x *= 0x27d4eb2d;
    x = x ^ (x >> 15);
    return x;
}

// パーティクルを物理制御。
void ApplyAccelerationAndSave(uint i, inout float3 pos, inout float3 vel, float3 targetPos)
{
    float3 diff = targetPos - pos;
    float distance = length(diff);
    
    // パラメータ
    float SlowingDistance = 5.0;
    
    float t = saturate(distance / SlowingDistance);
    
    float desiredSpeed = Speed * t;
    float safeDistance = max(distance, 1e-5);

    // 目標速度ベクトル。
    float3 desiredVelocity = (diff / safeDistance) * desiredSpeed;
    float3 steering = desiredVelocity - vel;
    
    // 加速度を適用。
    vel += steering * DeltaTime;
    vel *= AIR_RESISTANCE; // 空気抵抗を適用。

    // 最終的な位置を計算。
    pos += vel * DeltaTime;
    
    PositionBuffer[i] = pos;
    VelocityBuffer[i] = vel;
}


// 中心から離れるように加速するフェーズ。
[numthreads(64, 1, 1)]
void Phase1(uint id : SV_DispatchThreadID)
{
    if (id >= Phase1Count) { return; }
    
    uint i = Phase1Indices[id];
    float3 pos = PositionBuffer[i];
    float3 vel = VelocityBuffer[i];
    
    // 中心から無限遠を目標位置とすることで、離れる動きを表現
    float3 targetPos = pos + normalize(pos - CenterPosition) * 1000.0;
    
    ApplyAccelerationAndSave(i, pos, vel, targetPos);
}

// 円環を回るフェーズ。（デバッグ用）
[numthreads(64, 1, 1)]
void Phase2(uint id : SV_DispatchThreadID)
{
    if (id >= Phase2Count) { return; }

    uint i = Phase2Indices[id];

    // パーティクル固有の半径を計算
    float seed = Hash01(i);
    float radius = lerp(TorusMinRadius, TorusMaxRadius, seed);

    // --- デバッグここから ---
    // radiusの値を0.0～1.0の範囲に正規化
    // (radius - Min) / (Max - Min)
    float debug_value = saturate((radius - TorusMinRadius) / (TorusMaxRadius - TorusMinRadius));
    
    // 正規化した値をグレイスケールの色としてColorBufferに書き込む
    ColorBuffer[i] = float3(debug_value, debug_value, debug_value);
    // --- デバッグここまで ---
    
    // 動きは一時的に止める
    // ApplyAccelerationAndSave(i, pos, vel, targetPos);
}

// 公転する衛星のフェーズ。
[numthreads(64, 1, 1)]
void Phase3(uint id : SV_DispatchThreadID)
{
    if (id >= Phase3Count) { return; }
    
    uint i = Phase3Indices[id];
    float3 pos = PositionBuffer[i];
    float3 vel = VelocityBuffer[i];

    // 時間によって公転半径が変化
    float t = (cos(Time) + 1) / 2.0;
    float orbitalRadius = lerp(OrbitalMinRadius, OrbitalMaxRadius, t);
    
    // 所属する球のインデックスと、その球の公転角度を計算
    uint sphereIndex = HashUint(i) % OrbitalSphereCount;
    float spherePhase = (sphereIndex / (float) OrbitalSphereCount) * TAU;
    float angle = Time * OrbitalSpeed + spherePhase;

    // 球（衛星）の中心位置を計算
    float3 offsetedCenter = CenterPosition + OrbitalCenterOffset;
    float3 orbitCenter;
    sincos(angle, orbitCenter.z, orbitCenter.x);
    orbitCenter.x = offsetedCenter.x + orbitCenter.x * orbitalRadius;
    orbitCenter.z = offsetedCenter.z + orbitCenter.z * orbitalRadius;
    orbitCenter.y = offsetedCenter.y;
    
    // 球の表面上のランダムな位置を目標位置とする
    uint localSeed = i / OrbitalSphereCount;
    float seed1 = Hash01(localSeed * 17 + sphereIndex * 131);
    float seed2 = Hash01(localSeed * 59 + sphereIndex * 241);
    float theta = seed1 * TAU;
    float phi = acos(1.0 - 2.0 * seed2);
    float3 sphereDir;
    sincos(theta, sphereDir.z, sphereDir.x);
    sphereDir.x *= sin(phi);
    sphereDir.z *= sin(phi);
    sphereDir.y = cos(phi);
    
    float3 targetPos = orbitCenter + sphereDir * OrbitalSphereRadius;
    
    ApplyAccelerationAndSave(i, pos, vel, targetPos);
}


// あけおめ文字フェーズ。
[numthreads(64, 1, 1)]
void PhaseFinal(uint id : SV_DispatchThreadID)
{
    if (id >= PhaseFinalCount) { return; }
    
    uint i = PhaseFinalIndices[id];
    float3 pos = PositionBuffer[i];
    float3 vel = VelocityBuffer[i];
    
    float3 targetPos = TargetBuffer[i];
    
    // ターゲットとの距離が近ければ、動きを止める
    float distSq = dot(targetPos - pos, targetPos - pos);
    if (distSq <= StopDistance * StopDistance)
    {
        PositionBuffer[i] = targetPos;
        VelocityBuffer[i] = float3(0, 0, 0);
        return;
    }

    ApplyAccelerationAndSave(i, pos, vel, targetPos);
}

// HSVをRGBに変換する。
float3 HSVtoRGB(float h, float s, float v)
{
    float4 k = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(h + k.xyz) * 6.0 - k.www);
    return v * lerp(k.xxx, saturate(p - k.xxx), s);
}

[numthreads(256, 1, 1)]
void ColorUpdate(uint3 id : SV_DispatchThreadID)
{
    return;
    
    uint index = id.x;
    if (index >= ParticleCount) { return; }
    
    float3 pos = PositionBuffer[index];
    float3 diff = pos - CenterPosition;

    float dist = length(diff.xz);
    float3 color = float3(1, 1, 1);

    if (dist <= 5.0) // 内側の範囲
    {
        float hue = fmod(Time * 0.2, 1.0);
        color = HSVtoRGB(hue, 1, 1);
    }
    else
    {
        float angle = atan2(diff.z, diff.x) / TAU + 0.5;
        
        if (dist <= 8.0) // グラデーション範囲
        {
            float t = (dist - 5.0) / (8.0 - 5.0);
            float hue = lerp(1.0 / 6.0, angle, t);
            color = HSVtoRGB(hue, 1, 1);
        }
        else
        {
            color = HSVtoRGB(angle, 1, 1);
        }
    }

    ColorBuffer[index] = color;
}